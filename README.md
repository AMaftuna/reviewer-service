# Reviewer Service

Сервис для автоматического назначения ревьюеров на Pull Request’ы внутри команды, управления командами и активностью пользователей.  
Взаимодействие происходит через HTTP API, описанный в `openapi.yml`.

---

## Содержание

1. [Стек](#стек)
2. [Архитектура](#архитектура)
3. [Запуск](#запуск)
   - [Через docker-compose](#через-docker-compose)
4. [Дополнительные задания](#дополнительные-задания)
   - [Статистика](#статистика)
   - [Массовая деактивация и safe reassignment](#массовая-деактивация-и-safe-reassignment)
   - [Интеграционные тесты](#интеграционные-тесты)
   - [Нагрузочное тестирование](#нагрузочное-тестирование)
   - [Линтер](#линтер)

---

## Стек

- **Язык:** Go (1.23)
- **База данных:** PostgreSQL (16)
- **HTTP роутер:** [go-chi/chi](https://github.com/go-chi/chi)
- **DB-driver:** [pgx/v5](https://github.com/jackc/pgx)
- **Миграции:** [migrate](https://github.com/golang-migrate/migrate) (через отдельный контейнер)
- **Линтер:** [golangci-lint v2](https://golangci-lint.run)
- **Нагрузочное тестирование:** [Locust](https://locust.io/)

---

## Архитектура

Логически сервис разделён на несколько слоёв:

- `cmd/server` — точка входа, сборка зависимостей, запуск HTTP-сервера.
- `internal/config` — чтение конфигурации из переменных окружения.
- `internal/db` — инициализация пула подключений к Postgres.
- `internal/models` — доменные сущности (User, Team, PullRequest и т.д.).
- `internal/repo` — слой доступа к данным (SQL-запросы).
- `internal/service` — бизнес-логика:
  - выбор ревьюеров,
  - merge PR,
  - reassign,
  - массовая деактивация,
  - статистика.
- `internal/http` — HTTP-слой:
  - chi-роутер,
  - хендлеры,
  - DTO запросов/ответов,
  - маппинг ошибок.
- `internal/e2e` — интеграционные (E2E) тесты.

---

## Запуск

### Через docker-compose

В корне репозитория:

```bash
docker-compose up --build
````

Что произойдёт:

1. Поднимется контейнер `db` с PostgreSQL.
2. Контейнер `migrate` применит миграции к базе (`reviewer`).
3. Поднимется контейнер `app` с Go-сервисом на порту `8080`.

Проверка готовности:

```bash
curl http://localhost:8080/healthz
# {"ok":true}
```


## Дополнительные задания

### Статистика

Реализован эндпоинт:

* `GET /stats/get?by=users`
  Возвращает массив:

  ```json
  {
    "by_users": [
      { "user_id": "u2", "count": 2 },
      ...
    ]
  }
  ```

* `GET /stats/get?by=prs`
  Возвращает массив:

  ```json
  {
    "by_prs": [
      { "pull_request_id": "pr1", "count": 2 },
      ...
    ]
  }
  ```

Под капотом используется таблица `assignments_log`, куда пишутся события:

* `AUTO_ASSIGN` — автоматическое назначение при создании PR,
* `REASSIGN` — ручное пере-назначение,
* `SAFE_REASSIGN` — пере-назначение при массовой деактивации.

---

### Массовая деактивация и safe reassignment

Эндпоинт:

* `POST /team/deactivate`

Поведение:

1. Деактивируется список пользователей (одноразово; уже неактивные пропускаются).
2. Находятся **все открытые PR**, где эти пользователи были ревьюерами.
3. Для каждого такого ревьюера:

   * ищется замена:

     * из команды **деактивированного**,
     * только активные,
     * исключаются автор и текущие ревьюеры этого PR;
   * если кандидат найден — выполняется `SAFE_REASSIGN` (замена ревьюера);
   * если кандидата нет — ревьюер удаляется из PR (их становится 0/1).

Операция выполняется в транзакции и рассчитана на “средние объёмы” (до ~200 пользователей / до 20 команд).

---

### Интеграционные тесты

Файл:

* `internal/e2e/e2e_test.go`

Тесты:

* `TestE2E_CreatePR_AssignsActiveReviewers`
* `TestE2E_Deactivate_SafeReassign`

Тесты поднимают HTTP-сервер с реальной БД (используя `DATABASE_URL`) и гоняют сценарии end-to-end.

Запуск (из корня проекта):

```bash
export DATABASE_URL="postgres://postgres:postgres@localhost:5432/reviewer?sslmode=disable"
go test ./...
```

---

### Нагрузочное тестирование

Запущен нагрузочный тест на Python с использованием Locust (см. `loadtest/locust.py`).

Запуск (из корня проекта):

```bash
locust -f loadtest/locust.py --host=http://localhost:8080
```

Сценарий:
- при старте пользователя — один раз вызывается `POST /team/add` для команды `payments`;
- в каждой задаче:
  1. вызывается `POST /pullRequest/create` с уникальным `pull_request_id`;
  2. из ответа берутся назначенные ревьюеры; если список не пустой, вызывается `POST /pullRequest/reassign` для одного из них.

Параметры прогона:
- 10 пользователей (users)
- скорость появления 2 users/s
- продолжительность порядка 30 секунд

Результаты одного из прогонов (по данным веб-интерфейса Locust):

- `POST /pullRequest/create`
  - 1222 запросов, 0 ошибок
  - median ≈ 17 ms, p95 ≈ 23 ms, avg ≈ 16.9 ms
- `POST /pullRequest/reassign`
  - 1222 запросов, 0 ошибок
  - median ≈ 8 ms, p95 ≈ 11 ms, avg ≈ 7.6 ms
- `POST /team/add`
  - 10 запросов, 0 ошибок
- **Итого (Aggregated)**:
  - 2454 запросов, 0 ошибок
  - median ≈ 11 ms, p95 ≈ 21 ms, avg ≈ 12.2 ms
  - текущий RPS ≈ 86

Вывод: при нагрузке порядка 80–90 RPS сервис стабильно обрабатывает запросы без ошибок, а 95-й перцентиль времени ответа (≈ 21–23 ms) значительно лучше заявленного в задании SLI по времени (300 ms).

---

### Линтер

Используется golangci-lint, конфигурация лежит в `.golangci.yml` (формат v2).

Запуск:

```bash
golangci-lint run ./...
```

Включены линтеры:

* `govet`
* `staticcheck`
* `ineffassign`
* `unused`
* `errcheck`
* `revive` (с ограниченным набором правил, без жёстких требований к комментам)